Это занятие будет посвящено массивам и структурам данных

Начнём с массивов. Массив является цельньной памятью и в C++ доступ к нему осуществляется по указателю к первому элементу. Так выглядит объявление массива, состоящего из элементов типа int на 10 элементов:

```cpp
int arr[10];
```

Размер такого массива - 4 \times 10 байт.

Доступ к элементу массива будет осуществляться через оператор квадратных скобок:

```cpp
arr[4] = 5;
```

Такая запись будет трактоваться следующим образом -

```cpp
*(arr + 4) = 5;
```

Отсюда берётся следующий казус - записи arr[4] и 4[arr] являются идентичными, но давайте условимся использовать только первый вариант.

Память под такой массив выделяется на стэке. Соответственно, она будет освобождена при выходе из той области видимости, в которой была выделена (областью видимости называется секция кода между двумя фигурными скобками - это может быть как область цикла for, так и просто так поставленные две скобки). А значит, обращение к этой памяти будет вызывать undefined behavior.

Если нужно заранее выделить память и проинициализировать массив нужными значениями, это можно сделать при помощи такой вещи, как initializer list. При этом, нам необязательно указывать количество элементов в массиве - компилятор определит его за нас:

```cpp
int arr[] = {1, 2, 3, 4 5};
```

```cpp
int *foo() {
    int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    return arr;
}

int main() {
    int *p = foo();
    std::cout << p[2] << std::endl;
}
```

Например, вот этот код вызовет undefined behavior.

Также размер такого массива будет константным. То есть, его нельзя ни расширить, ни уменьшить.

Но что же делать если мы хотим выделять память в функции и возвращать её, или же создать массив, который можно будет потом расширить? В этом случае нам понадобится так называемая динамическая память. Её основная особенность в том, что она не очищается сама, и её надо очистить вручную когда она будет не нужна. Выделяется такая память при попощи оператора new, а освобождается применением функции delete.

```cpp
int main() {
    int *arr = new int[10];
    // some code
    delete[] arr;
}
```

Тогда мы сможем возвращать указатель на созданную память из функции

```cpp
int *foo(int size) {
    return new int[10];
}

int main() {
    int *arr = foo();
    arr[5] = 2;
    delete[] arr;
}
```

Вот этот код будет вполне легальным и отработает имено так, как мы хотим.

Теперь, когда мы умеем работать с памятью, в следующем уроке мы будем учиться писать саои структуры данных с использованием полученных навыков.
